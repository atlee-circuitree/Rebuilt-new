/* Generated by Phoenix Tuner X */
package frc.robot.subsystems;

import static edu.wpi.first.units.Units.*;

import java.util.function.DoubleSupplier;
import java.util.function.Supplier;

import com.ctre.phoenix6.BaseStatusSignal;
import com.ctre.phoenix6.CANBus;
import com.ctre.phoenix6.StatusSignal;
import com.ctre.phoenix6.Utils;
import com.ctre.phoenix6.configs.TalonFXConfiguration;
import com.ctre.phoenix6.controls.DutyCycleOut;
import com.ctre.phoenix6.controls.MotionMagicVoltage;
import com.ctre.phoenix6.hardware.TalonFX;
import com.ctre.phoenix6.signals.ForwardLimitSourceValue;
import com.ctre.phoenix6.signals.ForwardLimitTypeValue;
import com.ctre.phoenix6.signals.GravityTypeValue;
import com.ctre.phoenix6.signals.MotorAlignmentValue;
import com.ctre.phoenix6.signals.NeutralModeValue;
import com.ctre.phoenix6.signals.ReverseLimitSourceValue;
import com.ctre.phoenix6.signals.ReverseLimitTypeValue;
import com.ctre.phoenix6.sim.ChassisReference;
import com.ctre.phoenix6.sim.TalonFXSimState;

import edu.wpi.first.math.system.plant.DCMotor;
import edu.wpi.first.units.measure.*;
import edu.wpi.first.wpilibj.Notifier;
import edu.wpi.first.wpilibj.RobotController;
import edu.wpi.first.wpilibj.simulation.ElevatorSim;
import edu.wpi.first.wpilibj.smartdashboard.Mechanism2d;
import edu.wpi.first.wpilibj.smartdashboard.MechanismLigament2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.wpilibj2.command.button.Trigger;

public class Elevator extends SubsystemBase {
    /** Position setpoints for the elevator. */
    public enum Setpoint {
        Ground(Rotations.of(0)),
        Middle(Rotations.of(1)),
        Top(Rotations.of(3));

        /** The position target of the setpoint in angular units. */
        public final Angle target;
        /** The position target of the setpoint in linear units. */
        public final Distance targetDist;

        private Setpoint(Angle target) {
            this.target = target;
            this.targetDist = kDrumRadius.times(target.in(Radians));
        }
        private Setpoint(Distance target) {
            this.target = Radians.of(target.div(kDrumRadius).magnitude());
            this.targetDist = target;
        }
    }

    private static final int kNumConfigAttempts = 2;

    private static final double kGearRatio = 16.875;
    private static final Distance kDrumRadius = Meters.of(0.030733999999999997);
    private static final Distance kMaxHeight = Meters.of(0);

    /* leader and follower motors */
    private final CANBus kCANBus = new CANBus("FRC 1599B");
    private final TalonFX motor_id_20 = new TalonFX(20, kCANBus);

    /* device status signals */
    private final StatusSignal<Angle> motor_id_20Position = motor_id_20.getPosition(false);
    private final StatusSignal<AngularVelocity> motor_id_20Velocity = motor_id_20.getVelocity(false);
    private final StatusSignal<Current> motor_id_20TorqueCurrent = motor_id_20.getTorqueCurrent(false);

    /* controls used by the leader motors */
    private final MotionMagicVoltage setpointRequest = new MotionMagicVoltage(0);
    private final DutyCycleOut manualRequest = new DutyCycleOut(0);
    private final DutyCycleOut calibrationRequest = new DutyCycleOut(-0.1)
        .withIgnoreHardwareLimits(true)
        .withIgnoreSoftwareLimits(true);

    /** Trigger to detect when the elevator drives into a hard stop. */
    public final Trigger isHardStop = new Trigger(() -> {
        return motor_id_20Velocity.getValue().abs(RotationsPerSecond) < 1 &&
            motor_id_20TorqueCurrent.getValue().abs(Amps) > 10;
    }).debounce(0.1);

    /* simulation */
    private final ElevatorSim elevatorSim_motor_id_20 = new ElevatorSim(
        DCMotor.getKrakenX60Foc(1),
        kGearRatio, 5, kDrumRadius.in(Meters),
        0.0, kMaxHeight.in(Meters), true, 0.0
    );

    private static final double kSimLoopPeriod = 0.002; // 2 ms
    private Notifier simNotifier = null;
    private double lastSimTime = 0.0;

    /* Mechanism2d visualization of the elevator */
    private final Mechanism2d mech2d = new Mechanism2d(1, kMaxHeight.in(Meters));
    private final MechanismLigament2d motor_id_20Mech2d = mech2d.getRoot("motor_id_20 Root", 0.500, 0)
        .append(new MechanismLigament2d("motor_id_20", elevatorSim_motor_id_20.getPositionMeters(), 90));

    /** Configs common across all motors. */
    private static final TalonFXConfiguration motorInitialConfigs = new TalonFXConfiguration();

    /** Configs common across just the leader motors. */
    private static final TalonFXConfiguration leaderInitialConfigs = motorInitialConfigs.clone();

    /** Configs for {@link #motor_id_20}. */
    private final TalonFXConfiguration motor_id_20Configs = leaderInitialConfigs.clone()
        .withMotorOutput(
            leaderInitialConfigs.MotorOutput.clone()
                .withNeutralMode(NeutralModeValue.Coast)
        )
        .withCurrentLimits(
            leaderInitialConfigs.CurrentLimits.clone()
                .withStatorCurrentLimit(Amps.of(120))
                .withStatorCurrentLimitEnable(true)
        )
        .withSlot0(
            leaderInitialConfigs.Slot0.clone()
                .withKP(67.5)
                .withKI(0)
                .withKD(0)
                .withKS(0.2)
                .withKV(2.025)
                .withKA(0)
                .withKG(0)
                .withGravityType(GravityTypeValue.Elevator_Static)
        )
        .withFeedback(
            leaderInitialConfigs.Feedback.clone()
                .withSensorToMechanismRatio(16.875)
        )
        .withHardwareLimitSwitch(
            leaderInitialConfigs.HardwareLimitSwitch.clone()
                .withForwardLimitEnable(true)
                .withForwardLimitAutosetPositionEnable(false)
                .withForwardLimitRemoteSensorID(0)
                .withForwardLimitSource(ForwardLimitSourceValue.LimitSwitchPin)
                .withForwardLimitType(ForwardLimitTypeValue.NormallyOpen)
                .withReverseLimitAutosetPositionEnable(false)
                .withReverseLimitEnable(true)
                .withReverseLimitRemoteSensorID(0)
                .withReverseLimitSource(ReverseLimitSourceValue.LimitSwitchPin)
                .withReverseLimitType(ReverseLimitTypeValue.NormallyOpen)
        )
        .withMotionMagic(
            leaderInitialConfigs.MotionMagic.clone()
                .withMotionMagicCruiseVelocity(RotationsPerSecond.of(4.7407407407407405))
                .withMotionMagicAcceleration(RotationsPerSecondPerSecond.of(23.703703703703702))
        );

    public Elevator() {
        for (int i = 0; i < kNumConfigAttempts; ++i) {
            var status = motor_id_20.getConfigurator().apply(motor_id_20Configs);
            if (status.isOK()) break;
        }


        /* set the default command to neutral output */
        setDefaultCommand(manualDrive(() -> 0.0));
        /* alternatively, the default command can hold position */
        // setDefaultCommand(holdPosition());

        SmartDashboard.putData("Elevator", mech2d);

        if (Utils.isSimulation()) {
            startSimThread();
        }
    }

    /**
     * @return The Position of the elevator
     */
    public Angle getPosition() {
        return motor_id_20Position.getValue();
    }

    /**
     * @return The Velocity of the elevator
     */
    public AngularVelocity getVelocity() {
        return motor_id_20Velocity.getValue();
    }

    /**
     * @return The TorqueCurrent of the elevator
     */
    public Current getTorqueCurrent() {
        return motor_id_20TorqueCurrent.getValue();
    }

    /**
     * Holds the elevator at the current position using PID.
     *
     * @return Command to run
     */
    public Command holdPosition() {
        return runOnce(() ->
            setpointRequest.withPosition(motor_id_20Position.getValue())
        ).andThen(run(() -> {
            motor_id_20.setControl(setpointRequest);
        }));
    }

    /**
     * Drives the elevator to the provided position setpoint.
     *
     * @param setpoint Function returning the setpoint to apply
     * @return Command to run
     */
    public Command goToSetpoint(Supplier<Setpoint> setpoint) {
        return run(() -> {
            setpointRequest.withPosition(setpoint.get().target);
            motor_id_20.setControl(setpointRequest);
        });
    }

    /**
     * Manually drives the elevator with the provided duty cycle output.
     *
     * @param manualOutput Function returning the duty cycle to apply
     * @return Command to run
     */
    public Command manualDrive(DoubleSupplier manualOutput) {
        return run(() -> {
            manualRequest.withOutput(manualOutput.getAsDouble());
            motor_id_20.setControl(manualRequest);
        });
    }

    /**
     * Recalibrates the elevator zero point. This slowly drives the elevator
     * down until we see a drop in velocity and a spike in stator current,
     * indicating that we've hit a hard stop.
     *
     * @return Command to run
     */
    public Command calibrateZero() {
        return run(() -> {
            motor_id_20.setControl(calibrationRequest);
        })
        .until(isHardStop)
        .andThen(
            manualDrive(() -> 0.0).withTimeout(0.25)
                .finallyDo(() -> {
                    motor_id_20.setPosition(Rotations.of(0));
                })
        );
    }

    @Override
    public void periodic() {
        /* refresh all status signals */
        BaseStatusSignal.refreshAll(
            motor_id_20Position,
            motor_id_20Velocity,
            motor_id_20TorqueCurrent
        );

        motor_id_20Mech2d.setLength(
            motor_id_20Position.getValueAsDouble() * kDrumRadius.in(Meters) * 2 * Math.PI
        );
    }

    private void startSimThread() {
        motor_id_20.getSimState().Orientation = ChassisReference.CounterClockwise_Positive;
        motor_id_20.getSimState().setMotorType(TalonFXSimState.MotorType.KrakenX60);

        lastSimTime = Utils.getCurrentTimeSeconds();

        /* Run simulation at a faster rate so PID gains behave more reasonably */
        simNotifier = new Notifier(() -> {
            /* Calculate the time delta */
            final double currentTime = Utils.getCurrentTimeSeconds();
            final double deltaTime = currentTime - lastSimTime;
            lastSimTime = currentTime;

            final var motor_id_20Sim = motor_id_20.getSimState();

            /* First set the supply voltage of all the devices */
            motor_id_20Sim.setSupplyVoltage(RobotController.getBatteryVoltage());

            /* Then calculate the new position and velocity of the simulated elevator */
            elevatorSim_motor_id_20.setInputVoltage(motor_id_20Sim.getMotorVoltage());
            elevatorSim_motor_id_20.update(deltaTime);

            /* Apply the new rotor position and velocity to the motors (before gear ratio) */
            motor_id_20Sim.setRawRotorPosition(
                Radians.of(elevatorSim_motor_id_20.getPositionMeters() / kDrumRadius.in(Meters) * kGearRatio)
            );
            motor_id_20Sim.setRotorVelocity(
                RadiansPerSecond.of(elevatorSim_motor_id_20.getVelocityMetersPerSecond() / kDrumRadius.in(Meters) * kGearRatio)
            );
        });
        simNotifier.startPeriodic(kSimLoopPeriod);
    }
}